#!/usr/bin/env python3

"""
VirusTotal Scanner

This is a script that uses VirusTotal to scan files. VirusTotal has many
features, but this script only does file scanning. A VirusTotal API key is
required to use this script.

This program can be invoked as

```sh
vtscan [OPTIONS] FILES...
```

where `OPTIONS` are:

* `--hash=<bool>`, `-H`: Check files hashes.

and `FILES` are the files to check. Alternatively, if no files are passed,
they are read from `stdin`:

```sh
command ... | vtscan [OPTIONS]
```

A configuration file is used to set the API key and override default options.
It can appear in one of the following locations:

* `$XDG_CONFIG_HOME/vtscan/vtscan.json`
* `$HOME/.config/vtscan/vtscan.json`
* `$XDG_CONFIG_HOME/vtscan.json`
* `$HOME/.config/vtscan.json`
* `$HOME/vtscan.json`
* `$HOME/.vtscan.json`

The config file may contain the following JSON:

```json
{
    "apikey": <string>,
    "hash": <bool>
}
```

The fields are:

* `apikey` (required) can be either a string containing the API key or a string
  containing an absolute path to a file. If a file path is specified, that file
  should be a text file containing the API. The file is not JSON or any other
  format, just the API key, as the entire contents of the file are used as the
  API in this case. This option is useful if the API key is stored elsewhere,
  such as an ecrypted directory.
* `hash` (bool) indicates that file hashes should be tested before scanning the
  entire file. Searching for a hash counts against the quota, so if every hash
  misses and a scan must also be performed, the quota usage is double the
  number of files that were scanned.
"""

import argparse
import copy
import hashlib
import io
import json
import math
import os
import sys
import re
import time

try:
    import vt
except ImportError:
    print("vt-py must be installed", file=sys.stderr)
    sys.exit(1)

# ANSI color escapes
CNRM = "\033[0m"
CRED = "\033[91m"
CYEL = "\033[93m"
CGRN = "\033[92m"

# Functions to wrap a string with color escapes
color_red = lambda x: f"{CRED}{x}{CNRM}"
color_yel = lambda x: f"{CYEL}{x}{CNRM}"
color_grn = lambda x: f"{CGRN}{x}{CNRM}"

# The locations to search for config files.
CONFIG_FILES = [
    os.path.expandvars("$XDG_CONFIG_HOME/vtscan/vtscan.json"),
    os.path.expandvars("$HOME/.config/vtscan/vtscan.json"),
    os.path.expandvars("$XDG_CONFIG_HOME/vtscan.json"),
    os.path.expandvars("$HOME/.config/vtscan.json"),
    os.path.expandvars("$HOME/vtscan.json"),
    os.path.expandvars("$HOME/.vtscan.json"),
]

# Some fake stats data which can be used for testing
_TEST_STATS_DATA = {
    "confirmed-timeout": 3,
    "failure": 1,
    "harmless": 3,
    "malicious": 2,
    "suspicious": 7,
    "timeout": 4,
    "type-unsupported": 7,
    "undetected": 20,
}

class Stats:
    """
    The VirusTotal stats for a file.
    """

    def __init__(self, data):
        """
        Create a new stats object.

        # Arguments

        * data (dict): The JSON object that is returned by VirusTotal
            containing the stats.
        """
        self._data = copy.deepcopy(data)

    @property
    def confirmed_timeout(self):
        """(int) Number of engines that timeout when analyzing the file."""
        return self._data["confirmed-timeout"]

    @property
    def failure(self):
        """(int) Number of engines that failed to analyze the file."""
        return self._data["failure"]

    @property
    def harmless(self):
        """(int) Number of reports saying the file is harmless."""
        return self._data["harmless"]

    @property
    def malicious(self):
        """(int) Number of reports saying the file is malicious."""
        return self._data["malicious"]

    @property
    def suspicious(self):
        """(int) Number of reports saying the file is suspicious."""
        return self._data["suspicious"]

    @property
    def timeout(self):
        """(int) Number of timeouts when analyzing the file."""
        return self._data["timeout"]

    @property
    def type_unsupported(self):
        """(int) Number of engines that do not support the type of file."""
        return self._data["type-unsupported"]

    @property
    def undetected(self):
        """(int) Number of reports that did not detect anything."""
        return self._data["undetected"]

    # The weights for scoring the results. If a weight is None then it is not
    # considered in the score.
    _SCORE_WEIGHTS = {
        "confirmed-timeout": None,
        "failure": None,
        "harmless": 0.6,
        "malicious": 0.0,
        "suspicious": 0.2,
        "timeout": None,
        "type-unsupported": None,
        "undetected": 1.0,
    }

    @property
    def _count(self):
        """(int) Number of data points."""
        return sum(self._data.values())

    @property
    def _useful_count(self):
        """(int) The number of data points that have a weight."""
        count = 0
        for k, v in self._data.items():
            if self._SCORE_WEIGHTS[k] is not None:
                count += v
        return count

    @property
    def score(self):
        """
        Generate a safety score for the file.

        # Returns

        (float) A number between 0 and 1 (inclusive). 1 means the file is
        extremely likely to be safe, and 0 means it is not safe.
        """
        score = 0.0
        for k, v in self._data.items():
            if self._SCORE_WEIGHTS[k] is not None:
                score += self._SCORE_WEIGHTS[k] * v
        return score / self._useful_count

    @property
    def confidence(self):
        """
        A metric for how likely the score is to be accurate.

        # Returns

        (float) A number between 0 and 1 (inclusive). 1 means complete
        confidence that the score is accurate, and 0 means there is no
        confidence in the score accuracy.
        """
        # Compute a rating of how many useful data points there are
        usefulness = math.sqrt(self._useful_count / self._count)
        # Compute how tight (i.e. not spread) the data is
        xs = [
            self.harmless,
            self.malicious,
            self.suspicious,
            self.undetected,
        ]
        vs = []
        for k, v in self._data.items():
            if k in self._SCORE_WEIGHTS:
                vs.append(v)
        tightness = math.sqrt(abs(max(vs) ** 2 - min(vs) ** 2))
        tightness /= self._useful_count
        return math.sqrt(usefulness * tightness)

class ScanFile:
    """
    A class which can be used to scan one file.
    """

    def __init__(self, apikey, file, hash=True):
        """
        Create a new scanner.

        # Arguments

        * apikey (str): The VirusTotal API key to use.
        * file (io.BufferedReader): A reader for the file to scan.
        * hash (bool): Whether to first check the hashe before performing a
            full scan of the file.
        """
        # File
        if not isinstance(file, io.BufferedReader):
            raise ValueError("files must be a BufferedReader")
        self._file = file

        # Hash
        if not isinstance(hash, bool):
            raise ValueError("hash must be a bool")
        self._hash = hash

        # Connect to VirusTotal
        if not isinstance(apikey, str):
            raise ValueError("apikey must be a str")
        self._client = vt.Client(apikey)

        # Compute the stats
        self._stats = self._scan()

    def __del__(self):
        try:
            self._client.close()
        except vt.error.APIError:
            pass
        try:
            self._file.close()
        except IOError:
            pass

    @property
    def filename(self):
        """
        (str) The path to the file that was scanned.
        """
        return self._file.name

    @property
    def hash(self):
        """
        (bool) The hash option.
        """
        return self._hash

    @property
    def stats(self):
        """
        (Stats) The scan stats.
        """
        return copy.deepcopy(self._stats)

    def _scan(self):
        """
        Scan the file.

        # Returns

        (Stats) The file stats.

        # Raises

        * (IOError) The file is not found or cannot be opened.
        * (vt.error.APIError) There was an error with VirusTotal, most lilely
          the hash was not found.
        """
        if self.hash:
            try:
                return self._scan_hash()
            except (IOError, vt.error.APIError) as ex:
                # Hash does not exist
                pass
        # Hashing was disabled or a hash was not found, so scan the file.
        return self._scan_scan()

    def _scan_hash(self):
        """
        Look up a hash in the database.

        # Returns

        (Stats) The file stats.

        # Raises

        * (IOError) The file is not found or cannot be opened.
        * (vt.error.APIError) There was an error with VirusTotal, most lilely
          the hash was not found.
        """
        self._file.seek(0, 0)
        sha256 = hashlib.sha256(self._file.read()).hexdigest()
        result = self._client.get_object("/files/{}", sha256)
        return Stats(result.last_analysis_stats)

    def _scan_scan(self):
        """
        Scan a file.

        # Returns

        (Stats) The file stats.

        # Raises

        * (IOError) The file is not found or cannot be opened.
        * (vt.error.APIError) There was an error with VirusTotal.
        """
        self._file.seek(0, 0)
        result = self._client.scan_file(self._file, wait_for_completion=True)
        return Stats(result.stats)

def parse_args():
    """
    Parse the command line arguments.
    """
    def parse_bool(x):
        if isinstance(x, bool):
            return x
        elif isinstance(x, str):
            if x.lower() in ["true", "1"]:
                return True
            elif x.lower() in ["false", "0"]:
                return False
        raise argparse.ArgumentTypeError("Expected boolean")

    parser = argparse.ArgumentParser(
        description="Scan files with VirusTotal",
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("files",
        action="store", type=str, nargs="*",
        help="the files to scan")
    parser.add_argument("--hash", "-H", type=parse_bool, nargs="?",
        default=None, help="Enable or disable hashing.")

    return parser.parse_args()

def process_args(args):
    """
    Coalesce the command line arguments with the defaults and the options from
    the config.
    """
    # Start with default values
    opts = {
        "apikey": None,
        "files": args.files,
        "hash": True
    }
    # Update from config. The first config file that is found is used
    for cf in CONFIG_FILES:
        if os.path.isfile(cf):
            with open(cf) as f:
                c = json.load(f)
            for k, v in c.items():
                if k == "apikey":
                    if re.compile("^[A-Fa-f0-9]+$").match(v):
                        opts["apikey"] = v
                    else:
                        with open(os.path.expandvars(v)) as f:
                            opts["apikey"] = f.read().strip()
                elif k == "hash":
                    opts["hash"] = v
                else:
                    raise ValueError("invalid config key: {}".format(k))
            break
    # Update from command line
    if args.hash is not None:
        opts["hash"] = args.hash
    # Read the files from stdin if non are supplied on the command line
    if not opts["files"]:
        opts["files"] = list(map(lambda x: x[:-1], sys.stdin.readlines()))
    return opts

def fmt_result(filename, stats):
    """
    Format a result to print.
    """
    def fmt_num(n):
        s = "{:5.03f}".format(n)
        if not sys.stdout.isatty():
            return s
        if n < 0.500:
            return color_red(s)
        elif n < 0.750:
            return color_yel(s)
        else:
            return color_grn(s)
    score = fmt_num(stats.score)
    confidence = fmt_num(stats.confidence)
    return "{} {} {}".format(score, confidence, filename)

def main(opts):
    """
    Scan all of the files.
    """
    for file in opts["files"]:
        with open(file, "rb") as f:
            scan = ScanFile(opts["apikey"], f, hash=opts["hash"])
            print(fmt_result(f.name, scan.stats))

if __name__ == "__main__":
    args = parse_args()
    opts = process_args(args)
    main(opts)
